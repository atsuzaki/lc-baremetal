> require "core.llc"
> require "ix.llc"
> require "wvram.llc"
> require "keyboard.llc"

A clock display:

> clockLeft, clockRight :: Ix NumCols
> clockLeft              = modIx 70
> clockRight             = modIx 77

> export clock  :: Word -> Proc Unit
> clock t = clockLoop clockRight t

> clockLoop :: Ix NumCols -> Word -> Proc Unit
> clockLoop col t
>   = do update ((vram @ ix0) @ col)
>               (\c -> (c::Char)[char=digitToByte (t `and` 15)])
>        case clockLeft `ltDec` col of
>          Just j  -> clockLoop j (t `lshr` 4)
>          Nothing -> return Unit

The spinner:

> area spinpos <- initStored ix0 :: Ref (Stored (Ix 4))
> area spinner <- initArray (\ix -> initStored (wordToByte (spinChar ix))) :: Ref (Array 4 (Stored Byte))

> spinChar  :: Ix 4 -> Word
> spinChar x = if x `ltIx` ix2 then
>                if x `eqIx` ix0 then '-' else '\\'
>              else
>                if x `eqIx` ix2 then '|' else '/'

> export spin :: Proc Unit
> spin = do p <- get spinpos
>           c <- get (spinner @ p)
>           set spinpos (modIx (1 + ixToBit p))
>           let r = (vram @ ix0) @ modIx 79
>           o <- get r
>           set r o[char=c]

The "Knight Rider Bar":

> area pos <- initStored (modIx 55) :: Ref (Stored (Ix NumCols))
> area dir <- initStored True       :: Ref (Stored Bool)

> barmin = modIx 46 :: Ix NumCols
> barmax = modIx 68 :: Ix NumCols

> export bar :: Proc Unit
> bar = do p <- get pos
>          upd p ' '
>          if<- get dir
>            then case ltInc p barmax of
>                   Just j  -> upd j '>'
>                              set pos j
>                   Nothing -> upd p '|'
>                              set dir False
>            else case ltDec barmin p of
>                   Just i  -> upd i '<'
>                              set pos i
>                   Nothing -> upd p '|'
>                              set dir True
> upd p c = do let r = (vram @ ix0) @ p
>              oc <- get r
>              set r oc[char=wordToByte c]

Last key pressed display:

> keyRow = modIx 0
> keyCol = modIx 19

> export updateKeyDisplay :: Byte -> Proc Unit

> updateKeyDisplay key = do
>                         let r = (vram @ keyRow) @ keyCol
>                         o <- get r
>                         set r o[char=key]

The breakout game:

> type NumMaxGO         = 50           -- Just an arbitrary number
> type MaxGameObjects   = Ix NumMaxGO

TODO: I couldn't specify this type

> -- type GOArray         =  Array MaxGameObjects (Stored (Maybe GameObject))

TODO: Couldn't get these arrays to init either

> -- area activeObjects   <- initArrayAll Nothing  :: Ref (Array MaxGameObjects (Stored (Maybe GameObject)))
> -- area inactiveObjects <- initArrayAll Nothing  :: Ref (Array MaxGameObjects (Stored (Maybe GameObject)))

> struct GameObject
>   [ width       :: Stored Word
>   | height      :: Stored Word
>   | xPos        :: Stored Word
>   | yPos        :: Stored Word ]

> gameObject :: Word -> Word -> Word -> Word -> Init GameObject
> gameObject w h currentPosX currentPosY
>   = GameObject [ width  <- initStored w 
>                | height <- initStored h
>                | xPos   <- initStored currentPosX 
>                | yPos   <- initStored currentPosY ]

> area paddle <- gameObject 8 1 18 22 :: Ref GameObject
> area ball   <- gameObject 1 1 10 10 :: Ref GameObject

> export tickBreakout :: Ref Window -> Proc Unit
> tickBreakout w = do clearScreen
>                     drawGameObject ball w
>                     drawGameObject paddle w
>                     movePaddleSystem 

> drawGameObject :: Ref GameObject -> Ref Window -> Proc Unit
> drawGameObject go window
>  = do xPos   <- get go.xPos
>       wWidth <- getwidth window
> --    putUnsigned xPos
> --    puts "\n"
> --    putUnsigned (ixToBit wWidth)
> --    puts "\n"
>       case xPos <=? wWidth of
>         Nothing -> return Unit
>         Just x0 -> do yPos    <- get go.yPos
>                       wHeight <- getheight window
>                       case yPos <=? wHeight of
>                         Nothing -> return Unit
>                         Just y0 -> do width  <- get go.width
>                                       height <- get go.height
>                                       let x1 = minIx (xPos+width-1) wWidth     -- The -1 is needed here, else it renders 2 pixels instead of 1
>                                           y1 = minIx (yPos+height-1) wHeight
>                                       render x0 y0 x1 y1 window

> render            :: Ix 80 -> Ix 25 -> Ix 80 -> Ix 25 -> Ref Window -> Proc Unit
> render x0 y0 x1 y1 w = loop y0 y1 (\y ->
>                        loop x0 x1 (\x ->
>                        wputpixel w ' ' (wordToByte 0x70) y x))

> -- renderSystem w = do let b = get ball
> --                     wputpixel w (digitToByte 254) (wordToByte 0x70) b.currentPos

Manually inlined `isKeyDown` logic into here I guess since for the love of god
I couldn't get this to work with that method

> movePaddleSystem :: Proc Unit
> movePaddleSystem = do kd <- get keyDown 
>                       ku <- get keyUp
>                       if (('6' == (bitsToWord kd)) && ('6' /= (bitsToWord ku)))
>                         then xPos <- get paddle.xPos
>                              set paddle.xPos (xPos + 1)
>                       if (('4' == (bitsToWord kd)) && ('4' /= (bitsToWord ku)))
>                         then xPos <- get paddle.xPos
>                              set paddle.xPos (xPos - 1)


> -- movePaddleSystem = do if (isKeyDown '6')
> --                         then xPos <- get paddle.xPos
> --                              set paddle.xPos (xPos + 1)
>                       -- if (isKeyDown '4')
>                       --   then xPos <- get paddle.xPos
>                       --        set paddle.xPos (xPos - 1)

---
Utility functions
---

> loop :: Ix n -> Ix n -> (Ix n -> Proc Unit) -> Proc Unit  -- library function?
> loop x0 x1 f
>       = do f x0
>            case x0 `ltInc` x1 of
>              Nothing -> return Unit
>              Just nx -> loop nx x1 f


> minIx    :: Word -> Ix n -> Ix n  -- library function?
> minIx w i = case w <=? i of
>               Nothing -> i
>               Just j  -> j


