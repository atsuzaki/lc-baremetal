> require "core.llc"
> require "ix.llc"
> require "wvram.llc"

A clock display:

> clockLeft, clockRight :: Ix NumCols
> clockLeft              = modIx 70
> clockRight             = modIx 77

> export clock  :: Word -> Proc Unit
> clock t = clockLoop clockRight t

> clockLoop :: Ix NumCols -> Word -> Proc Unit
> clockLoop col t
>   = do update ((vram @ ix0) @ col)
>               (\c -> (c::Char)[char=digitToByte (t `and` 15)])
>        case clockLeft `ltDec` col of
>          Just j  -> clockLoop j (t `lshr` 4)
>          Nothing -> return Unit

The spinner:

> area spinpos <- initStored ix0 :: Ref (Stored (Ix 4))
> area spinner <- initArray (\ix -> initStored (wordToByte (spinChar ix))) :: Ref (Array 4 (Stored Byte))

> spinChar  :: Ix 4 -> Word
> spinChar x = if x `ltIx` ix2 then
>                if x `eqIx` ix0 then '-' else '\\'
>              else
>                if x `eqIx` ix2 then '|' else '/'

> export spin :: Proc Unit
> spin = do p <- get spinpos
>           c <- get (spinner @ p)
>           set spinpos (modIx (1 + ixToBit p))
>           let r = (vram @ ix0) @ modIx 79
>           o <- get r
>           set r o[char=c]

The "Knight Rider Bar":

> area pos <- initStored (modIx 55) :: Ref (Stored (Ix NumCols))
> area dir <- initStored True       :: Ref (Stored Bool)

> barmin = modIx 46 :: Ix NumCols
> barmax = modIx 68 :: Ix NumCols

> export bar :: Proc Unit
> bar = do p <- get pos
>          upd p ' '
>          if<- get dir
>            then case ltInc p barmax of
>                   Just j  -> upd j '>'
>                              set pos j
>                   Nothing -> upd p '|'
>                              set dir False
>            else case ltDec barmin p of
>                   Just i  -> upd i '<'
>                              set pos i
>                   Nothing -> upd p '|'
>                              set dir True
> upd p c = do let r = (vram @ ix0) @ p
>              oc <- get r
>              set r oc[char=wordToByte c]

Last key pressed display:

> keyRow = modIx 0
> keyCol = modIx 19

> export updateKeyDisplay :: Byte -> Proc Unit

> updateKeyDisplay key = do
>                         let r = (vram @ keyRow) @ keyCol
>                         o <- get r
>                         set r o[char=key]

The breakout game:

> type NumMaxGO         = 50           -- Just an arbitrary number
> type MaxGameObjects   = Ix NumMaxGO

TODO: I couldn't specify this type

> -- type GOArray         =  Array MaxGameObjects (Stored (Maybe GameObject))

TODO: Couldn't get these arrays to init either

> -- area activeObjects   <- initArrayAll Nothing  :: Ref (Array MaxGameObjects (Stored (Maybe GameObject)))
> -- area inactiveObjects <- initArrayAll Nothing  :: Ref (Array MaxGameObjects (Stored (Maybe GameObject)))

> struct GameObject
>   [ width       :: Stored Word
>   | height      :: Stored Word
>   | currentPos  :: Coord       ] -- TODO: don't use Coord, pos could be off screen
>                                  -- TODO: remember to treat it as relative pos

> gameObject :: Word -> Word -> Ix NumRows -> Ix NumCols -> Init GameObject
> gameObject w h currentPosX currentPosY
>   = let currentPos = initCoord currentPosX currentPosY
>     in GameObject [ width  <- initStored w 
>                   | height <- initStored h
>                   | currentPos ]

> area ball <- gameObject 1 1 (modIx 10) (modIx 10) :: Ref GameObject

> export tickBreakout :: Ref Window -> Proc Unit
> tickBreakout w = do clearScreen
>                     renderBall w
> --                  renderSystem w -- For when things are working the normal way later

> renderBall :: Ref Window -> Proc Unit
> renderBall w = -- do curPos <- get ball.currentPos
>                   wputpixel w ' ' (wordToByte 0x70) ball.currentPos

> -- renderSystem w = do let b = get ball
> --                     wputpixel w (digitToByte 254) (wordToByte 0x70) b.currentPos

> --  movePaddleSystem :: Proc Unit
> --  movePaddleSystem  = do

